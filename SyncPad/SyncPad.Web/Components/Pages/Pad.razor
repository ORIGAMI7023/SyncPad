@page "/pad"
@using SyncPad.Client.Core.Services
@using SyncPad.Shared.Models
@inject IAuthManager AuthManager
@inject IApiClient ApiClient
@inject ITextHubClient TextHubClient
@inject IFileClient FileClient
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>é¢æ¿ - SyncPad</PageTitle>

<div class="pad-layout">
    <!-- å·¦ä¾§ä¸»åŒºåŸŸï¼ˆæ–‡æœ¬ç¼–è¾‘ï¼‰ -->
    <div class="text-area">
        <!-- é¡¶éƒ¨å·¥å…·æ  -->
        <div class="toolbar">
            <div class="user-info">
                <span>ç”¨æˆ·: <strong>@AuthManager.Username</strong></span>
            </div>
            <div class="toolbar-actions">
                <button class="btn-secondary" @onclick="RefreshText">åˆ·æ–°</button>
                <button class="btn-danger" @onclick="Logout">ç™»å‡º</button>
            </div>
        </div>

        <!-- æ–‡æœ¬ç¼–è¾‘åŒºåŸŸ -->
        <div class="editor-container">
            <textarea @bind="_content" @bind:event="oninput" @onkeyup="HandleTextChange" placeholder="åœ¨è¿™é‡Œè¾“å…¥æ–‡æœ¬..."></textarea>
        </div>

        <!-- çŠ¶æ€æ  -->
        <div class="status-bar">
            <div class="connection-status">
                <span class="status-indicator @(_isConnected ? "connected" : "disconnected")"></span>
                <span>@_connectionStatus</span>
            </div>
        </div>
    </div>

    <!-- å³ä¾§æ–‡ä»¶åŒºåŸŸ -->
    <div class="file-area">
        <!-- æ–‡ä»¶åŒºåŸŸæ ‡é¢˜æ  -->
        <div class="file-header">
            <h3>æ–‡ä»¶åˆ—è¡¨</h3>
            <label class="btn-primary upload-btn">
                ä¸Šä¼ 
                <InputFile OnChange="HandleFileSelected" style="display: none;" />
            </label>
        </div>

        <!-- æ–‡ä»¶ç½‘æ ¼ -->
        <div class="file-grid @(_isDraggingExternal ? "drag-over" : "")"
             @ref="_fileGridRef"
             @onclick="OnFileGridClick"
             @ondragenter:preventDefault="true"
             @ondragenter="OnExternalDragEnter"
             @ondragleave:preventDefault="true"
             @ondragleave="OnExternalDragLeave"
             @ondragover:preventDefault="true"
             @ondrop:preventDefault="true"
             @ondrop="OnGridDrop">
            @if (_files.Count == 0)
            {
                <div class="empty-state">æš‚æ— æ–‡ä»¶</div>
            }
            else
            {
                @foreach (var file in _files)
                {
                    var downloadUrl = FileClient.GetDownloadUrl(file.File.Id);
                    <div class="file-card @(file.IsSelected ? "selected" : "") @(_draggedFile == file ? "dragging" : "") @(_dropTarget == file ? "drop-target" : "")"
                         draggable="true"
                         data-file-id="@file.File.Id"
                         data-download-url="@downloadUrl"
                         data-file-name="@file.File.FileName"
                         @ondragstart="(e) => OnDragStart(e, file)"
                         @ondragenter="(e) => OnCardDragEnter(e, file)"
                         @ondragover:preventDefault="true"
                         @ondrop:preventDefault="true"
                         @ondrop:stopPropagation="true"
                         @ondrop="(e) => OnCardDrop(e, file)"
                         @ondragend="OnDragEnd"
                         @onclick="(e) => HandleFileClick(e, file)"
                         @onclick:stopPropagation="true"
                         @ondblclick="() => DownloadFile(file)">
                        <div class="file-icon-container">
                            <div class="file-icon">@file.FileIcon</div>
                            @if (!string.IsNullOrEmpty(file.StatusBadge))
                            {
                                <div class="status-badge">@file.StatusBadge</div>
                            }
                        </div>
                        <div class="file-name" title="@file.File.FileName">@file.File.FileName</div>
                        <div class="file-meta">@file.FileSizeText Â· @file.StatusText</div>
                        @if (file.ShowProgress)
                        {
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: @(file.DownloadProgress)%"></div>
                            </div>
                        }
                    </div>
                }
            }
        </div>

        <!-- æ‰¹é‡æ“ä½œå·¥å…·æ  -->
        @if (SelectedFilesCount > 0)
        {
            <div class="batch-toolbar">
                <span class="batch-info">å·²é€‰æ‹© @SelectedFilesCount ä¸ªæ–‡ä»¶</span>
                <button class="btn-success btn-sm" @onclick="BatchDownload">æ‰¹é‡ä¸‹è½½</button>
                <button class="btn-danger btn-sm" @onclick="BatchDelete">æ‰¹é‡åˆ é™¤</button>
                <button class="btn-secondary btn-sm" @onclick="ClearSelection">å–æ¶ˆ</button>
            </div>
        }
    </div>
</div>

<style>
    .pad-layout {
        display: flex;
        height: 100vh;
        background-color: #f5f5f5;
    }

    .text-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        border-right: 1px solid #ddd;
    }

    .file-area {
        width: 520px;
        display: flex;
        flex-direction: column;
        background-color: white;
    }

    .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 20px;
        background-color: white;
        border-bottom: 1px solid #ddd;
    }

    .user-info {
        color: #666;
    }

    .toolbar-actions {
        display: flex;
        gap: 10px;
    }

    .btn-secondary, .btn-primary, .btn-success, .btn-danger {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .btn-secondary {
        background-color: #6c757d;
        color: white;
    }

    .btn-secondary:hover {
        background-color: #5a6268;
    }

    .btn-primary {
        background-color: #007bff;
        color: white;
    }

    .btn-primary:hover {
        background-color: #0069d9;
    }

    .btn-success {
        background-color: #28a745;
        color: white;
    }

    .btn-success:hover {
        background-color: #218838;
    }

    .btn-danger {
        background-color: #dc3545;
        color: white;
    }

    .btn-danger:hover {
        background-color: #c82333;
    }

    .btn-sm {
        padding: 6px 12px;
        font-size: 12px;
    }

    .btn-icon {
        padding: 6px 10px;
        font-size: 16px;
    }

    .editor-container {
        flex: 1;
        padding: 20px;
    }

    .editor-container textarea {
        width: 100%;
        height: 100%;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 16px;
        font-family: inherit;
        resize: none;
        box-sizing: border-box;
    }

    .editor-container textarea:focus {
        outline: none;
        border-color: #007bff;
    }

    .status-bar {
        padding: 10px 20px;
        background-color: white;
        border-top: 1px solid #ddd;
    }

    .connection-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        color: #666;
    }

    .status-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
    }

    .status-indicator.connected {
        background-color: #28a745;
    }

    .status-indicator.disconnected {
        background-color: #dc3545;
    }

    .file-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background-color: #e9ecef;
        border-bottom: 1px solid #ddd;
    }

    .file-header h3 {
        margin: 0;
        font-size: 16px;
    }

    .upload-btn {
        cursor: pointer;
        margin: 0;
    }

    .file-grid {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 4px;
        align-content: start;
        transition: background-color 0.2s;
    }

    .file-grid.drag-over {
        background-color: rgba(0, 123, 255, 0.05);
        outline: 2px dashed rgba(0, 123, 255, 0.4);
        outline-offset: -10px;
    }

    .empty-state {
        grid-column: 1 / -1;
        text-align: center;
        padding: 40px 20px;
        color: #999;
        font-size: 14px;
    }

    .file-card {
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 8px;
        cursor: pointer;
        transition: all 0.1s;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
        width: 100%;
        box-sizing: border-box;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    .file-card:hover {
        background-color: rgba(0, 120, 212, 0.08);
        border-color: rgba(0, 120, 212, 0.2);
    }

    .file-card.selected {
        background-color: rgba(0, 120, 212, 0.2);
        border-color: rgba(0, 120, 212, 0.5);
    }

    .file-card.selected:hover {
        background-color: rgba(0, 120, 212, 0.25);
        border-color: rgba(0, 120, 212, 0.6);
    }

    .file-card.dragging {
        opacity: 0.4;
    }

    .file-card.drop-target {
        background-color: rgba(0, 120, 212, 0.15);
        border-color: rgba(0, 120, 212, 0.5);
        border-style: dashed;
    }

    .file-icon-container {
        position: relative;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 4px;
    }

    .file-icon {
        font-size: 32px;
    }

    .status-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        font-size: 12px;
    }

    .file-name {
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        line-height: 1.4;
        height: 34px;
        word-break: break-all;
        min-width: 0;
    }

    .file-meta {
        font-size: 10px;
        color: #6c757d;
        text-align: center;
        height: 14px;
    }

    .progress-bar {
        height: 4px;
        background-color: #e9ecef;
        border-radius: 2px;
        overflow: hidden;
        margin-top: 4px;
    }

    .progress-fill {
        height: 100%;
        background-color: #007bff;
        transition: width 0.3s ease;
    }

    .batch-toolbar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px;
        background-color: #f8f9fa;
        border-top: 1px solid #ddd;
    }

    .batch-info {
        flex: 1;
        font-size: 12px;
        color: #666;
    }

    /* å“åº”å¼è®¾è®¡ */
    @@media (max-width: 768px) {
        .pad-layout {
            flex-direction: column;
        }

        .text-area {
            border-right: none;
            border-bottom: 1px solid #ddd;
        }

        .file-area {
            width: 100%;
            flex: 1;
        }

        .file-grid {
            grid-template-columns: repeat(2, 1fr);
        }
    }

    /* å¹³æ¿å’Œå°å±å¹• */
    @@media (max-width: 1024px) and (min-width: 769px) {
        .file-grid {
            grid-template-columns: repeat(3, 1fr);
        }
    }
</style>

@code {
    private string _content = string.Empty;
    private string _connectionStatus = "æœªè¿æ¥";
    private bool _isConnected = false;
    private bool _isUpdatingFromServer = false;
    private bool _isInitialized = false;
    private CancellationTokenSource? _throttleCts;
    private readonly object _throttleLock = new();

    // æ–‡ä»¶åˆ—è¡¨
    private List<SelectableFileItemWeb> _files = new();
    private int SelectedFilesCount => _files.Count(f => f.IsSelected);
    private int _lastSelectedIndex = -1;

    // æ‹–æ”¾çŠ¶æ€
    private SelectableFileItemWeb? _draggedFile = null;
    private SelectableFileItemWeb? _dropTarget = null;
    private bool _isDraggingExternal = false;
    private bool _isInternalDrag = false;
    private ElementReference _fileGridRef;
    private DotNetObjectReference<Pad>? _dotNetRef;

    protected override void OnInitialized()
    {
        // è®¢é˜…äº‹ä»¶ï¼ˆåªè®¢é˜…ä¸€æ¬¡ï¼‰
        TextHubClient.ConnectionStateChanged += OnConnectionStateChanged;
        TextHubClient.TextUpdateReceived += OnTextUpdateReceived;
        TextHubClient.FileUpdateReceived += OnFileUpdateReceived;
        TextHubClient.FilePositionChanged += OnFilePositionChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            _isInitialized = true;

            // å…ˆå°è¯•æ¢å¤ä¼šï¿½ï¿½ï¿½ï¼ˆéœ€è¦ JS äº’æ“ä½œï¼‰
            await AuthManager.TryRestoreSessionAsync();

            // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
            if (!AuthManager.IsLoggedIn)
            {
                Navigation.NavigateTo("/login");
                return;
            }

            // åˆå§‹åŒ–æ‹–æ”¾åŒºåŸŸçš„ JS äº’æ“ä½œ
            _dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("DragDropInterop.initDropZone", _fileGridRef, _dotNetRef);

            // è¿æ¥ SignalR
            await ConnectToHub();

            // åŠ è½½åˆå§‹æ–‡æœ¬
            await RefreshText();

            // åŠ è½½æ–‡ä»¶åˆ—è¡¨
            await RefreshFiles();
        }
    }

    private async Task ConnectToHub()
    {
        try
        {
            _connectionStatus = "è¿æ¥ä¸­...";
            StateHasChanged();

            var hubUrl = AuthManager.GetHubUrl();
            var token = AuthManager.Token;

            if (!string.IsNullOrEmpty(token))
            {
                await TextHubClient.ConnectAsync(hubUrl, token);
            }
        }
        catch (Exception ex)
        {
            _connectionStatus = $"è¿æ¥å¤±è´¥: {ex.Message}";
            StateHasChanged();
        }
    }

    private async Task RefreshText()
    {
        try
        {
            var response = await ApiClient.GetTextAsync();
            if (response.Success && response.Data != null)
            {
                _isUpdatingFromServer = true;
                _content = response.Data.Content;
                _isUpdatingFromServer = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"åˆ·æ–°æ–‡æœ¬å¤±è´¥: {ex.Message}");
        }
    }

    private async Task RefreshFiles()
    {
        try
        {
            var response = await FileClient.GetFilesAsync();
            if (response.Success && response.Data != null)
            {
                _files = response.Data.Files.Select(f => new SelectableFileItemWeb(f)).ToList();
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"åˆ·æ–°æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {ex.Message}");
        }
    }

    private void HandleTextChange()
    {
        if (!_isUpdatingFromServer)
        {
            ThrottleSendUpdate();
        }
    }

    private void ThrottleSendUpdate()
    {
        lock (_throttleLock)
        {
            _throttleCts?.Cancel();
            _throttleCts = new CancellationTokenSource();
            var token = _throttleCts.Token;
            var currentContent = _content;

            Task.Delay(300, token).ContinueWith(async _ =>
            {
                if (!token.IsCancellationRequested && TextHubClient.IsConnected)
                {
                    await TextHubClient.SendTextUpdateAsync(currentContent);
                }
            }, TaskContinuationOptions.OnlyOnRanToCompletion);
        }
    }

    private void OnConnectionStateChanged(bool connected)
    {
        InvokeAsync(() =>
        {
            _isConnected = connected;
            _connectionStatus = connected ? "å·²è¿æ¥" : "å·²æ–­å¼€";
            StateHasChanged();
        });
    }

    private void OnTextUpdateReceived(TextSyncMessage message)
    {
        InvokeAsync(() =>
        {
            _isUpdatingFromServer = true;
            _content = message.Content;
            _isUpdatingFromServer = false;
            StateHasChanged();
        });
    }

    private void OnFileUpdateReceived(FileSyncMessage message)
    {
        InvokeAsync(() =>
        {
            switch (message.Action)
            {
                case "added":
                    if (message.File != null)
                    {
                        var existing = _files.FirstOrDefault(f => f.File.FileName == message.File.FileName);
                        if (existing != null)
                            _files.Remove(existing);

                        _files.Insert(0, new SelectableFileItemWeb(message.File));
                    }
                    break;

                case "deleted":
                    if (message.FileId.HasValue)
                    {
                        var toRemove = _files.FirstOrDefault(f => f.File.Id == message.FileId.Value);
                        if (toRemove != null)
                            _files.Remove(toRemove);
                    }
                    break;
            }

            StateHasChanged();
        });
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            await UploadFile(file);
        }
    }

    private async Task UploadFile(Microsoft.AspNetCore.Components.Forms.IBrowserFile file)
    {
        try
        {
            // æ£€æŸ¥åŒåæ–‡ä»¶
            if (await FileClient.FileExistsAsync(file.Name))
            {
                // Web ç¯å¢ƒä¸‹ä½¿ç”¨ JS Interop æ¥æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œç›´æ¥è¦†ç›–
                using var stream = file.OpenReadStream(maxAllowedSize: 100 * 1024 * 1024);
                await FileClient.UploadFileAsync(file.Name, stream, file.ContentType, overwrite: true);
            }
            else
            {
                using var stream = file.OpenReadStream(maxAllowedSize: 100 * 1024 * 1024);
                var response = await FileClient.UploadFileAsync(file.Name, stream, file.ContentType);

                if (!response.Success)
                {
                    Console.WriteLine($"ä¸Šä¼ å¤±è´¥: {response.ErrorMessage}");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ä¸Šä¼ æ–‡ä»¶å¤±è´¥: {ex.Message}");
        }
    }

    private void HandleFileClick(Microsoft.AspNetCore.Components.Web.MouseEventArgs e, SelectableFileItemWeb file)
    {
        var currentIndex = _files.IndexOf(file);

        if (e.CtrlKey)
        {
            // Ctrl + å•å‡»ï¼šåˆ‡æ¢é€‰ä¸­çŠ¶æ€
            file.IsSelected = !file.IsSelected;
            _lastSelectedIndex = file.IsSelected ? currentIndex : -1;
        }
        else if (e.ShiftKey && _lastSelectedIndex >= 0)
        {
            // Shift + å•å‡»ï¼šèŒƒå›´é€‰æ‹©
            var startIndex = Math.Min(_lastSelectedIndex, currentIndex);
            var endIndex = Math.Max(_lastSelectedIndex, currentIndex);

            for (int i = startIndex; i <= endIndex; i++)
            {
                _files[i].IsSelected = true;
            }
        }
        else
        {
            // æ™®é€šå•å‡»ï¼šæ¸…é™¤å…¶ä»–é€‰æ‹©ï¼Œä»…é€‰ä¸­å½“å‰
            foreach (var f in _files)
            {
                f.IsSelected = false;
            }
            file.IsSelected = true;
            _lastSelectedIndex = currentIndex;
        }

        StateHasChanged();
    }

    private void DownloadFile(SelectableFileItemWeb file)
    {
        var url = FileClient.GetDownloadUrl(file.File.Id);
        Navigation.NavigateTo(url, true);
    }

    private async Task DeleteFile(SelectableFileItemWeb file)
    {
        // ç®€åŒ–å¤„ç†ï¼Œç›´æ¥åˆ é™¤
        try
        {
            var response = await FileClient.DeleteFileAsync(file.File.Id);
            if (!response.Success)
            {
                Console.WriteLine($"åˆ é™¤å¤±è´¥: {response.ErrorMessage}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"åˆ é™¤æ–‡ä»¶å¤±è´¥: {ex.Message}");
        }
    }

    private void OnFileSelectionChanged()
    {
        StateHasChanged();
    }

    private void ToggleSelection(SelectableFileItemWeb file)
    {
        file.IsSelected = !file.IsSelected;
        StateHasChanged();
    }

    private void ClearSelection()
    {
        foreach (var file in _files)
        {
            file.IsSelected = false;
        }
        StateHasChanged();
    }

    // ç‚¹å‡»ç©ºç™½åŒºåŸŸå–æ¶ˆé€‰ä¸­
    private void OnFileGridClick(Microsoft.AspNetCore.Components.Web.MouseEventArgs e)
    {
        // å¦‚æœç‚¹å‡»çš„æ˜¯ç©ºç™½åŒºåŸŸï¼ˆä¸æ˜¯æ–‡ä»¶å¡ç‰‡ï¼‰ï¼Œå–æ¶ˆæ‰€æœ‰é€‰ä¸­
        ClearSelection();
    }

    // å†…éƒ¨æ‹–æ”¾äº‹ä»¶å¤„ç†
    private void OnDragStart(Microsoft.AspNetCore.Components.Web.DragEventArgs e, SelectableFileItemWeb file)
    {
        _draggedFile = file;
        _isInternalDrag = true;
        _dropTarget = null;
        StateHasChanged();
    }

    private void OnCardDragEnter(Microsoft.AspNetCore.Components.Web.DragEventArgs e, SelectableFileItemWeb targetFile)
    {
        // åªåœ¨å†…éƒ¨æ‹–åŠ¨æ—¶é«˜äº®ç›®æ ‡
        if (_isInternalDrag && _draggedFile != null && _draggedFile != targetFile)
        {
            _dropTarget = targetFile;
            StateHasChanged();
        }
    }

    private async Task OnCardDrop(Microsoft.AspNetCore.Components.Web.DragEventArgs e, SelectableFileItemWeb targetFile)
    {
        _dropTarget = null;

        if (_draggedFile == null || _draggedFile == targetFile)
        {
            _isInternalDrag = false;
            return;
        }

        // äº¤æ¢ä½ç½®ï¼šå°†ä¸¤ä¸ªæ–‡ä»¶çš„ä½ç½®äº’æ¢
        var draggedIndex = _files.IndexOf(_draggedFile);
        var targetIndex = _files.IndexOf(targetFile);

        if (draggedIndex >= 0 && targetIndex >= 0)
        {
            // åœ¨åˆ—è¡¨ä¸­äº¤æ¢ä½ç½®
            (_files[draggedIndex], _files[targetIndex]) = (_files[targetIndex], _files[draggedIndex]);

            // é€šçŸ¥æœåŠ¡å™¨æ›´æ–°ä½ç½®ï¼ˆå¯é€‰ï¼šå¦‚æœéœ€è¦æŒä¹…åŒ–ä½ç½®ï¼‰
            // è¿™é‡Œä½¿ç”¨åˆ—è¡¨ç´¢å¼•ä½œä¸ºä½ç½®
            await TextHubClient.UpdateFilePositionAsync(_draggedFile.File.Id, targetIndex, 0);
            await TextHubClient.UpdateFilePositionAsync(targetFile.File.Id, draggedIndex, 0);
        }

        _draggedFile = null;
        _isInternalDrag = false;
        StateHasChanged();
    }

    private void OnDragEnd()
    {
        _draggedFile = null;
        _dropTarget = null;
        _isInternalDrag = false;
        StateHasChanged();
    }

    // ç½‘æ ¼æ‹–æ”¾äº‹ä»¶ï¼ˆç”¨äºå¤–éƒ¨æ–‡ä»¶æ‹–å…¥ï¼‰
    private void OnExternalDragEnter()
    {
        if (!_isInternalDrag)
        {
            _isDraggingExternal = true;
            StateHasChanged();
        }
    }

    private void OnExternalDragLeave()
    {
        _isDraggingExternal = false;
        StateHasChanged();
    }

    private async Task OnGridDrop(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        _isDraggingExternal = false;
        _dropTarget = null;

        // å¦‚æœæ˜¯å†…éƒ¨æ‹–åŠ¨åˆ°ç©ºç™½å¤„ï¼Œå–æ¶ˆæ‹–åŠ¨
        if (_isInternalDrag)
        {
            _draggedFile = null;
            _isInternalDrag = false;
            StateHasChanged();
            return;
        }

        // å¤–éƒ¨æ–‡ä»¶æ‹–å…¥ç”± JS äº’æ“ä½œå¤„ç†
        StateHasChanged();
    }

    // JS äº’æ“ä½œå›è°ƒï¼šå¤–éƒ¨æ–‡ä»¶æ‹–å…¥
    [JSInvokable]
    public async Task OnFilesDropped(FileDropInfo[] files)
    {
        if (files == null || files.Length == 0)
            return;

        for (int i = 0; i < files.Length; i++)
        {
            try
            {
                // é€šè¿‡ JS è¯»å–æ–‡ä»¶å†…å®¹
                var fileData = await JSRuntime.InvokeAsync<FileDataInfo>("DragDropInterop.readDroppedFile", i);
                if (fileData != null)
                {
                    // å°† base64 è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
                    var bytes = Convert.FromBase64String(fileData.Data);
                    using var stream = new MemoryStream(bytes);

                    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒåæ–‡ä»¶
                    bool overwrite = await FileClient.FileExistsAsync(fileData.Name);

                    // ä¸Šä¼ æ–‡ä»¶
                    await FileClient.UploadFileAsync(fileData.Name, stream, fileData.Type, overwrite);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ä¸Šä¼ æ–‡ä»¶å¤±è´¥: {ex.Message}");
            }
        }

        // æ¸…ç†æš‚å­˜çš„æ–‡ä»¶
        await JSRuntime.InvokeVoidAsync("DragDropInterop.clearDroppedFiles");
    }

    // JS äº’æ“ä½œç”¨çš„æ•°æ®ç±»
    public class FileDropInfo
    {
        public string Name { get; set; } = string.Empty;
        public long Size { get; set; }
        public string Type { get; set; } = string.Empty;
    }

    public class FileDataInfo
    {
        public string Name { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public long Size { get; set; }
        public string Data { get; set; } = string.Empty;
    }

    private void OnFilePositionChanged(int fileId, int positionX, int positionY)
    {
        InvokeAsync(() =>
        {
            var file = _files.FirstOrDefault(f => f.File.Id == fileId);
            if (file != null)
            {
                // é‡æ–°åˆ›å»ºæ–‡ä»¶é¡¹ä»¥æ›´æ–°ä½ç½®
                var index = _files.IndexOf(file);
                if (index >= 0)
                {
                    var updatedDto = new FileItemDto
                    {
                        Id = file.File.Id,
                        FileName = file.File.FileName,
                        FileSize = file.File.FileSize,
                        MimeType = file.File.MimeType,
                        UploadedAt = file.File.UploadedAt,
                        ExpiresAt = file.File.ExpiresAt,
                        PositionX = positionX,
                        PositionY = positionY
                    };

                    var updatedItem = new SelectableFileItemWeb(updatedDto)
                    {
                        Status = file.Status,
                        DownloadProgress = file.DownloadProgress,
                        IsSelected = file.IsSelected
                    };

                    _files[index] = updatedItem;
                }
            }
            StateHasChanged();
        });
    }

    private void BatchDownload()
    {
        foreach (var file in _files.Where(f => f.IsSelected))
        {
            DownloadFile(file);
        }
    }

    private async Task BatchDelete()
    {
        var filesToDelete = _files.Where(f => f.IsSelected).ToList();
        foreach (var file in filesToDelete)
        {
            await DeleteFile(file);
        }
        ClearSelection();
    }

    private async Task Logout()
    {
        await TextHubClient.DisconnectAsync();
        await AuthManager.LogoutAsync();
        Navigation.NavigateTo("/login");
    }

    public void Dispose()
    {
        TextHubClient.ConnectionStateChanged -= OnConnectionStateChanged;
        TextHubClient.TextUpdateReceived -= OnTextUpdateReceived;
        TextHubClient.FileUpdateReceived -= OnFileUpdateReceived;
        TextHubClient.FilePositionChanged -= OnFilePositionChanged;
        _throttleCts?.Cancel();
        _throttleCts?.Dispose();
        _dotNetRef?.Dispose();
    }

    // Web ä¸“ç”¨çš„å¯é€‰æ‹©æ–‡ä»¶é¡¹
    private class SelectableFileItemWeb
    {
        public FileItemDto File { get; }
        public bool IsSelected { get; set; }
        public FileStatus Status { get; set; } = FileStatus.Remote;
        public int DownloadProgress { get; set; }

        // UI è¾…åŠ©å±æ€§
        public string StatusText => Status switch
        {
            FileStatus.Remote => "äº‘ç«¯",
            FileStatus.PreloadPending => "é˜Ÿåˆ—ä¸­",
            FileStatus.Preloading => $"é¢„è½½ä¸­ {DownloadProgress}%",
            FileStatus.Cached => "å·²ç¼“å­˜",
            _ => "æœªçŸ¥"
        };

        public bool ShowProgress => Status == FileStatus.Preloading;

        public string FileIcon => GetFileIcon(File.MimeType);

        public string StatusBadge => Status switch
        {
            FileStatus.Remote => "â˜ï¸",
            FileStatus.PreloadPending => "ğŸ•",
            FileStatus.Cached => "âœ“",
            _ => ""
        };

        public string FileSizeText => FormatFileSize(File.FileSize);

        public SelectableFileItemWeb(FileItemDto file)
        {
            File = file;
        }

        private string GetFileIcon(string? mimeType)
        {
            if (string.IsNullOrEmpty(mimeType))
                return "ğŸ“";

            return mimeType switch
            {
                _ when mimeType.StartsWith("image/") => "ğŸ“·",
                _ when mimeType.StartsWith("video/") => "ğŸ¬",
                _ when mimeType.StartsWith("audio/") => "ğŸµ",
                "application/pdf" => "ğŸ“„",
                "application/msword" => "ğŸ“„",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document" => "ğŸ“„",
                "text/plain" => "ğŸ“„",
                "application/zip" => "ğŸ“¦",
                "application/x-rar-compressed" => "ğŸ“¦",
                "application/x-7z-compressed" => "ğŸ“¦",
                "application/x-tar" => "ğŸ“¦",
                "text/html" => "ğŸ’»",
                "text/css" => "ğŸ’»",
                "application/javascript" => "ğŸ’»",
                "text/javascript" => "ğŸ’»",
                "application/json" => "ğŸ’»",
                "application/xml" => "ğŸ’»",
                _ when mimeType.Contains("csharp") => "ğŸ’»",
                _ when mimeType.Contains("python") => "ğŸ’»",
                _ when mimeType.Contains("java") => "ğŸ’»",
                _ => "ğŸ“"
            };
        }

        private string FormatFileSize(long bytes)
        {
            string[] sizes = { "B", "KB", "MB", "GB" };
            double len = bytes;
            int order = 0;
            while (len >= 1024 && order < sizes.Length - 1)
            {
                order++;
                len = len / 1024;
            }
            return $"{len:0.#} {sizes[order]}";
        }
    }
}
